// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from '@graphprotocol/graph-ts'

export class NewAdmin extends ethereum.Event {
  get params(): NewAdmin__Params {
    return new NewAdmin__Params(this)
  }
}

export class NewAdmin__Params {
  _event: NewAdmin

  constructor(event: NewAdmin) {
    this._event = event
  }

  get oldAdmin(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get newAdmin(): Address {
    return this._event.parameters[1].value.toAddress()
  }
}

export class NewAggregator extends ethereum.Event {
  get params(): NewAggregator__Params {
    return new NewAggregator__Params(this)
  }
}

export class NewAggregator__Params {
  _event: NewAggregator

  constructor(event: NewAggregator) {
    this._event = event
  }

  get cToken(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get source(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get data(): Bytes {
    return this._event.parameters[2].value.toBytes()
  }
}

export class NewPendingAdmin extends ethereum.Event {
  get params(): NewPendingAdmin__Params {
    return new NewPendingAdmin__Params(this)
  }
}

export class NewPendingAdmin__Params {
  _event: NewPendingAdmin

  constructor(event: NewPendingAdmin) {
    this._event = event
  }

  get oldPendingAdmin(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get newPendingAdmin(): Address {
    return this._event.parameters[1].value.toAddress()
  }
}

export class PriceOracle2__aggregatorsResult {
  value0: Address
  value1: Bytes

  constructor(value0: Address, value1: Bytes) {
    this.value0 = value0
    this.value1 = value1
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>()
    map.set('value0', ethereum.Value.fromAddress(this.value0))
    map.set('value1', ethereum.Value.fromBytes(this.value1))
    return map
  }
}

export class PriceOracle2 extends ethereum.SmartContract {
  static bind(address: Address): PriceOracle2 {
    return new PriceOracle2('PriceOracle2', address)
  }

  admin(): Address {
    let result = super.call('admin', 'admin():(address)', [])

    return result[0].toAddress()
  }

  try_admin(): ethereum.CallResult<Address> {
    let result = super.tryCall('admin', 'admin():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  aggregators(param0: Address): PriceOracle2__aggregatorsResult {
    let result = super.call('aggregators', 'aggregators(address):(address,bytes)', [
      ethereum.Value.fromAddress(param0),
    ])

    return new PriceOracle2__aggregatorsResult(result[0].toAddress(), result[1].toBytes())
  }

  try_aggregators(param0: Address): ethereum.CallResult<PriceOracle2__aggregatorsResult> {
    let result = super.tryCall('aggregators', 'aggregators(address):(address,bytes)', [
      ethereum.Value.fromAddress(param0),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(
      new PriceOracle2__aggregatorsResult(value[0].toAddress(), value[1].toBytes()),
    )
  }

  getUnderlyingPrice(cToken: Address): BigInt {
    let result = super.call(
      'getUnderlyingPrice',
      'getUnderlyingPrice(address):(uint256)',
      [ethereum.Value.fromAddress(cToken)],
    )

    return result[0].toBigInt()
  }

  try_getUnderlyingPrice(cToken: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      'getUnderlyingPrice',
      'getUnderlyingPrice(address):(uint256)',
      [ethereum.Value.fromAddress(cToken)],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  isPriceOracle(): boolean {
    let result = super.call('isPriceOracle', 'isPriceOracle():(bool)', [])

    return result[0].toBoolean()
  }

  try_isPriceOracle(): ethereum.CallResult<boolean> {
    let result = super.tryCall('isPriceOracle', 'isPriceOracle():(bool)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  pendingAdmin(): Address {
    let result = super.call('pendingAdmin', 'pendingAdmin():(address)', [])

    return result[0].toAddress()
  }

  try_pendingAdmin(): ethereum.CallResult<Address> {
    let result = super.tryCall('pendingAdmin', 'pendingAdmin():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this)
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this)
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall

  constructor(call: ConstructorCall) {
    this._call = call
  }

  get _oracle(): Address {
    return this._call.inputValues[0].value.toAddress()
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall

  constructor(call: ConstructorCall) {
    this._call = call
  }
}

export class AcceptAdminCall extends ethereum.Call {
  get inputs(): AcceptAdminCall__Inputs {
    return new AcceptAdminCall__Inputs(this)
  }

  get outputs(): AcceptAdminCall__Outputs {
    return new AcceptAdminCall__Outputs(this)
  }
}

export class AcceptAdminCall__Inputs {
  _call: AcceptAdminCall

  constructor(call: AcceptAdminCall) {
    this._call = call
  }
}

export class AcceptAdminCall__Outputs {
  _call: AcceptAdminCall

  constructor(call: AcceptAdminCall) {
    this._call = call
  }
}

export class SetAggregatorsCall extends ethereum.Call {
  get inputs(): SetAggregatorsCall__Inputs {
    return new SetAggregatorsCall__Inputs(this)
  }

  get outputs(): SetAggregatorsCall__Outputs {
    return new SetAggregatorsCall__Outputs(this)
  }
}

export class SetAggregatorsCall__Inputs {
  _call: SetAggregatorsCall

  constructor(call: SetAggregatorsCall) {
    this._call = call
  }

  get _ctokenAddresses(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray()
  }

  get _sources(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray()
  }

  get _datas(): Array<Bytes> {
    return this._call.inputValues[2].value.toBytesArray()
  }
}

export class SetAggregatorsCall__Outputs {
  _call: SetAggregatorsCall

  constructor(call: SetAggregatorsCall) {
    this._call = call
  }
}

export class SetPendingAdminCall extends ethereum.Call {
  get inputs(): SetPendingAdminCall__Inputs {
    return new SetPendingAdminCall__Inputs(this)
  }

  get outputs(): SetPendingAdminCall__Outputs {
    return new SetPendingAdminCall__Outputs(this)
  }
}

export class SetPendingAdminCall__Inputs {
  _call: SetPendingAdminCall

  constructor(call: SetPendingAdminCall) {
    this._call = call
  }

  get newPendingAdmin(): Address {
    return this._call.inputValues[0].value.toAddress()
  }
}

export class SetPendingAdminCall__Outputs {
  _call: SetPendingAdminCall

  constructor(call: SetPendingAdminCall) {
    this._call = call
  }
}
